![Git_logo](git_logo.png)

# Работа с Git
## 1. Проверка наличия установленного Git
В терминале выполнить команду:
```
git version
```
Если git установлен, появится сообщение с информацией о версии программы. Иначе будет сообщение об ошибке.
## 2. Установка Git
Загружаем псоледнюю версию Git  с оффициального сайта https://git-scm.com/downloads.

Устанавливаем с настройками по умолчанию.
## 3. Настройка Git 
При первом исполькозовании Git необходимо представиться, для этого необходимо ввести две команды
```
git config --global user.name "Ваше Имя"
git config --global user.email "Ваш email"
```
## 4. Создание репозитория
Создать репозиторию можно двумя способами
1. В терминале переходим к папке, в которой хотим создать репозитори. Необходимо ввести команду
```
git init
```
2. КлонИровать существующий репозиторий Git из любого места. С помошью команды
 ```
 git clone 'указать адрес'
 ```
 
## 5. Запись изменений в репозиторий 
**Определение состояния файлов**

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда `git status`. Если вы выполните эту команду сразу после клонирования, вы увидите что-то вроде этого:
```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```
Это означает, что у вас чистый рабочий каталог, другими словами — в нем нет отслеживаемых измененных файлов. Git также не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены здесь. Наконец, команда сообщает вам на какой ветке вы находитесь и сообщает вам, что она не расходится с веткой на сервере.

Предположим, вы добавили в свой проект новый файл, простой файл `file_name`. Если этого файла раньше не было, и вы выполните git status, вы увидите свой неотслеживаемый файл вот так:
```
$ echo 'My Project' > file_name
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    file_name

nothing added to commit but untracked files present (use "git add" to track)
```
 
 Понять, что новый файл неотслеживаемый можно по тому, что он находится в секции «Untracked files» в выводе команды status. Статус Untracked означает, что Git видит файл, которого не было в предыдущем снимке состояния (коммите); Git не станет добавлять его в ваши коммиты, пока вы его явно об этом не попросите. Это предохранит вас от случайного добавления в репозиторий сгенерированных бинарных файлов или каких-либо других, которые вы и не думали добавлять.

**Отслеживание новых файлов**
Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда `git add`. Чтобы начать отслеживание файла, вы можете выполнить следующее:
```
git add file_name 
```
Используем клавишу Tab для автозаполнения названия файла. 

Если вы снова выполните команду `status`, то увидите, что файл теперь отслеживаемый и добавлен в индекс:

```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)

    new file:   file_name
```

Вы можете видеть, что файл проиндексирован, так как он находится в секции «Changes to be committed». Если вы выполните коммит в этот момент, то версия файла, существовавшая на момент выполнения вами команды `git add`, будет добавлена в историю снимков состояния. Как вы помните, когда вы ранее выполнили `git init`, затем вы выполнили `git add (файлы)` — это было сделано для того, чтобы добавить файлы в вашем каталоге под версионный контроль. Команда `git add` принимает параметром путь к файлу или каталогу, если это каталог, команда рекурсивно добавляет все файлы из указанного каталога в индекс.

**Индексация изменённых файлов**

Давайте модифицируем файл, уже находящийся под версионным контролем. Если вы измените отслеживаемый фfile_name.md и после этого снова выполните команду `git status`, то результат будет примерно следующим:
```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
```

Файл находится в секции «Changes not staged for commit» — это означает, что отслеживаемый файл был изменён в рабочем каталоге, но пока не проиндексирован. Чтобы проиндексировать его, необходимо выполнить команду `git add`. Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния. Вам может быть понятнее, если вы будете думать об этом как «добавить этот контент в следующий коммит», а не как «добавить этот файл в проект». Выполним `git add`, чтобы проиндексировать файл, а затем снова выполним `git status`:
```
$ git add 
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   
    modified:   
```

 Теперь оба файла проиндексированы и войдут в следующий коммит. В этот момент вы, предположим, вспомнили одно небольшое изменение, которое вы хотите сделать в файле до коммита. Вы открываете файл, вносите и сохраняете необходимые изменения и вроде бы готовы к коммиту. Но давайте-ка ещё раз выполним `git status`:

 ```
$ vim .
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   
    modified:   

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   
 ```
 Теперь файл отображается как проиндексированный и непроиндексированный одновременно. Как такое возможно? Такая ситуация наглядно демонстрирует, что Git индексирует файл в точности в том состоянии, в котором он находился, когда вы выполнили команду `git add`. Если вы выполните коммит сейчас, то файл попадёт в коммит в том состоянии, в котором он находился, когда вы последний раз выполняли команду `git add` , а не в том, в котором он находится в вашем рабочем каталоге в момент выполнения `git commit`. Если вы изменили файл после выполнения `git add`, вам придётся снова выполнить `git add`, чтобы проиндексировать последнюю версию файла:
```
$ git add 
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   
    modified:   
```
**Просмотр индексированных и неиндексированных изменений**

Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите
```
git diff
```
Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения.

Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить
```
git diff --staged
```
Эта команда сравнивает ваши проиндексированные изменения с последним коммитом.

Важно отметить, что `git diff` сама по себе не показывает все изменения сделанные с последнего коммита — только те, что ещё не проиндексированы. Такое поведение может сбивать с толку, так как если вы проиндексируете все свои изменения, то git diff ничего не вернёт.

**Коммит изменений**

Простейший способ зафиксировать изменения — это набрать
```
git commit
```
Эта команда откроет выбранный вами текстовый редактор/

Есть и другой способ — вы можете набрать свой комментарий к коммиту в командной строке вместе с командой commit указав его после параметра -m, как в следующем примере:
```
$ git commit -m "Story 182: fix benchmarks for speed"
[master 463dc4f] Story 182: fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
```

## 6. Просмотр истории коммитов

После того, как вы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, вероятно вам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда

```
git log
git log --oneline
```

Опция `oneline` выводит каждый коммит в одну строку, что может быть очень удобным если вы просматриваете большое количество коммитов.

## 7. Операции отмены 
В любой момент вам может потребоваться что-либо отменить. Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит — внесите необходимые изменения, добавьте их в индекс и сделайте коммит ещё раз, указав параметр
```
git commit --amend
```
Эта команда использует область подготовки (индекс) для внесения правок в коммит. Если вы ничего не меняли с момента последнего коммита (например, команда запущена сразу после предыдущего коммита), то снимок состояния останется в точности таким же, а всё что вы сможете изменить — это ваше сообщение к коммиту.

**Отмена индексации файла**

Если вы изменили два файла и хотите добавить их в разные коммиты, но случайно выполнили команду `git add` и добавили в индекс оба. Прямо под текстом «Changes to be committed» говорится используйте
```
git reset HEAD <file> - Данная команда исключит файл из индекса. 
```
**Отмена изменений в файле**

С помощью команды `git checkout` можно вернуться к тому состоянию, что было в последнем комите. 

Пример работы команды

```
 git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
```

**Отмена действий с помощью git restore**

Git версии 2.23.0 представил новую команду: `git restore`. По сути, это альтернатива `git reset`. Начиная с версии 2.23.0, Git будет использовать `git restor`e вместо `git reset`t для многих операций отмены.

Для отмены действий в файле необходимо исользовать команду

```
git restore --staged <file>
```

Важно понимать, что `git restore <file>` — опасная команда. Любые локальные изменения, внесенные в этот файл, исчезнут — Git просто заменит файл последней зафиксированной версией. Никогда не используйте эту команду, если точно не знаете, нужны ли вам эти несохраненные локальные изменения.

**Перемещени между сохранениями или ветками**

С помошью команды `git checkout` (ID сохранения) можно пернемещяться между сохранениями.
Для того чтобы вернуться в изначальную ветку ( ветку масте) необходимо ввести команду `git checkout master`

## 8. Игнорирование файлов

Для игнорирования файлов, необходимо создать новый файл .gitignoire и прописать в него все необходимые файлы какие Git должен игнорировать. 

## 9. Работа с ветками
Что такое развление в Git? -  Вы отклоняетесь от основной линии разработки и продолжаете работу независимо от неё, не вмешиваясь в основную линию. В отличие от многих других репозиториев, Git поощряет процесс работы, при котором ветвление и слияние выполняется часто, даже по несколько раз в день. Понимание и владение этой функциональностью дает вам уникальный и мощный инструмент, который может полностью изменить привычный процесс разработки.

Давайте рассмотрим основные функции разветвления в Git.

**Создание веток**

Для создания новой ветки необходимо ввести команду `git branch` и добавить к ней название новой ветки. 

Пример:
`git branch new_branches`.

Если необходимо проверить создана ли новая ветка или на какой ветке вы сейчас находитель, просто введите команду `git branch` 

**Слияние веток**
Для слияния веток существует команда: `git merge`

Давайте рассмотрим правильный порядок действий для избежания ошибок и потери данных.

1. Сохраняем все изменения в ветке и проврерям на какой ветке мы сейчас находимся командой  `git branch`
2. Переходим на ветку master командой `git checkout master`
3. Для слияния веток водим команду `git merge` и название ветки для слияния. Пример: `git merge merge_branches`

**Разрешение конфликтов**

При работе с ветками и их слиянием, могут возникнуть конфликты, какие Git не может решить самостоятельно. После успешного слияния git предложит  выбрать вам вариант, что необьходимо оставить в текущей версии. 

Пример конфиликта:

![Пример конфликта](conflict.png)

Можно выбрать версию что была в основной ветке, выбрать версию что пришла из побоченной ветки, оставить оба и отредактировать в ручную, или написать всё с нуля. 

После решения конфликта необходимо сделать коммит. т.е сохранить изменения. 

**Удаление веток**

Для удаления уже ненужной ветки необходимо ввести команду:
```
git branch - d
```
В данном случае если какие-либо изменения не сохранены, или ветки не слиты, Git об этом подскажет. 
Для удаления ветки с несохранёнными изменениями необходимо ввести команду:
```
git branch -D
```

D- должна быть с большой буквы, тогда ветка будет удалена с игнорированием всех предупреждений о несохранённых данных.  

## 10. Работа с удалёнными репозиториями. 

Для работы с удалёнными репозиториями можно исполдьзовать такой серсвис как GitHab.

GitHub — это крупнейшее хранилище Git репозиториев, а так же центр сотрудничества для миллионов разработчиков и проектов. Огромный процент всех репозиториев хранится на GitHub, а многие проекты с открытым исходным кодом используют его ради Git хостинга, баг-трекера, рецензирования кода и других вещей.

Для начала работы необходимо зарегестрировать на сайте GitHb по [ссылке](https://github.com).

После прохождение регистрации мы можем начать работать с репозитоиями удалённо. Расмотрим какие возможносммти у нас появляются. 

### Создание нового репозитория.

Для создания необходимо зайти на GitHab. В правом верхнем углу  нажать на значёк **+** и выбрать new repozitory.
Выбрать необходимые настройки и завершить создание репозитория.

Далее с ним можно работать как онлайн на сервисе GitHab так и локально на компьютере.

### Создание ответвлений (fork).

Если вы хотите вносить свой вклад в уже существующие проекты, в которых у нас нет прав на внесения изменений путём отправки (push) изменений, вы можете создать своё собственное ответвление (fork) проекта. Это означает, что GitHub создаст вашу собственную копию проекта, данная копия будет находиться в вашем пространстве имён и вы сможете легко делать изменения путём отправки (push) изменений.

1. Если репозиторий находиться в открытом доступе, необходимо найти его и нажать в правом верхнем углу конпку Fork - этим действием вы создатите точную копию репозитория разработчика, с полным доступом к нему у вас в профиле и возможностью редактирования. 

2. Переходим в свой профиль, находим клонированный репозиторий. Нажимаем на ссылку данного репозитория и копируем её.

3. Далее в Git вводим команду 

```
git clone https://github.com/Contrl20l/SCV_Git_0107.git
```
Тем самым вы создадите копию проекта в Git на вашем локальном компьютере.

3. Меняем папку ослеживания командой 
```
cd "имя папки" - без скобок
```
4. Создаём новую ветку и начинаем работу над репозиторием. 

### Создание запроса на слияние.

После того как вы скачали и дработали и сохранили все изменения в проект другого человека. Необходимо предложить ему принять ваши изменения в его проекте. 

Для начала нам необходимо загрузить проделаную работу в нашу копию репозитория на GitHab. Для этого вводим команду

```
git push --set-upstream origin Git_instruction
```
Git_instruction - это имя созданной вами ветки. 

Теперь, если мы зайдём на страничку нашей копии на GitHub, мы увидим, что GitHub заметил наши изменения и предлагает открыть запрос на слияние с помощью большой зелёной кнопки.

Также можно зайти на страницу «Branches», по адресу https://github.com/user/project/branches, найти интересующую ветку и открыть запрос оттуда.

Если нажать на эту кнопку, появится экран ввода заголовка и описания предлагаемых изменений на рассмотрение владельцу проекта. Рекомендуется серьёзно подойти к составлению описания и сделать его максимально информативным, чтобы владелец проекта понимал, зачем эти изменения и какую пользу они принесут.

Также мы видим список коммитов в нашей тематической ветке, «опередивших» ветку master.

После создания запроса на слияние (путём нажатия кнопки «Create pull request» на этой странице) владелец форкнутого проекта получит уведомление о предложенных изменениях со ссылкой на страницу с информацией о запросе.